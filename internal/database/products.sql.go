// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: products.sql

package database

import (
	"context"
	"database/sql"
)

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (product_name, description, unit_price, supplier_id)
VALUES ($1, $2, $3, $4)
RETURNING product_id, product_name, description, unit_price, supplier_id
`

type CreateProductParams struct {
	ProductName string
	Description sql.NullString
	UnitPrice   float64
	SupplierID  int32
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, createProduct,
		arg.ProductName,
		arg.Description,
		arg.UnitPrice,
		arg.SupplierID,
	)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.ProductName,
		&i.Description,
		&i.UnitPrice,
		&i.SupplierID,
	)
	return i, err
}

const getProductById = `-- name: GetProductById :one
SELECT product_id, product_name, description, unit_price, supplier_id FROM products
WHERE product_id = $1
`

func (q *Queries) GetProductById(ctx context.Context, productID int32) (Product, error) {
	row := q.db.QueryRowContext(ctx, getProductById, productID)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.ProductName,
		&i.Description,
		&i.UnitPrice,
		&i.SupplierID,
	)
	return i, err
}

const getProductsByLocationId = `-- name: GetProductsByLocationId :many
SELECT s.product_id, location_id, quantity, p.product_id, product_name, description, unit_price, supplier_id FROM stocks AS s 
JOIN products AS p ON p.product_id = s.product_id 
WHERE location_id = $1
ORDER BY p.product_id
LIMIT $2
OFFSET $3
`

type GetProductsByLocationIdParams struct {
	LocationID int32
	Limit      int32
	Offset     int32
}

type GetProductsByLocationIdRow struct {
	ProductID   int32
	LocationID  int32
	Quantity    int32
	ProductID_2 int32
	ProductName string
	Description sql.NullString
	UnitPrice   float64
	SupplierID  int32
}

func (q *Queries) GetProductsByLocationId(ctx context.Context, arg GetProductsByLocationIdParams) ([]GetProductsByLocationIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByLocationId, arg.LocationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByLocationIdRow
	for rows.Next() {
		var i GetProductsByLocationIdRow
		if err := rows.Scan(
			&i.ProductID,
			&i.LocationID,
			&i.Quantity,
			&i.ProductID_2,
			&i.ProductName,
			&i.Description,
			&i.UnitPrice,
			&i.SupplierID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsBySupplierId = `-- name: GetProductsBySupplierId :many
SELECT s.product_id, location_id, quantity, p.product_id, product_name, description, unit_price, supplier_id FROM stocks AS s 
JOIN products AS p ON p.product_id = s.product_id 
WHERE supplier_id = $1
ORDER BY p.product_id
LIMIT $2
OFFSET $3
`

type GetProductsBySupplierIdParams struct {
	SupplierID int32
	Limit      int32
	Offset     int32
}

type GetProductsBySupplierIdRow struct {
	ProductID   int32
	LocationID  int32
	Quantity    int32
	ProductID_2 int32
	ProductName string
	Description sql.NullString
	UnitPrice   float64
	SupplierID  int32
}

func (q *Queries) GetProductsBySupplierId(ctx context.Context, arg GetProductsBySupplierIdParams) ([]GetProductsBySupplierIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsBySupplierId, arg.SupplierID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsBySupplierIdRow
	for rows.Next() {
		var i GetProductsBySupplierIdRow
		if err := rows.Scan(
			&i.ProductID,
			&i.LocationID,
			&i.Quantity,
			&i.ProductID_2,
			&i.ProductName,
			&i.Description,
			&i.UnitPrice,
			&i.SupplierID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products
SET unit_price = $1, description = $2, supplier_id = $3
WHERE product_id = $4
RETURNING product_id, product_name, description, unit_price, supplier_id
`

type UpdateProductParams struct {
	UnitPrice   float64
	Description sql.NullString
	SupplierID  int32
	ProductID   int32
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, updateProduct,
		arg.UnitPrice,
		arg.Description,
		arg.SupplierID,
		arg.ProductID,
	)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.ProductName,
		&i.Description,
		&i.UnitPrice,
		&i.SupplierID,
	)
	return i, err
}
