// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: products.sql

package database

import (
	"context"
	"database/sql"
)

const createProduct = `-- name: CreateProduct :many
INSERT INTO "products" ("product_name", "description", "unit_price", "supplier_id")
VALUES (?, ?, ?, ?)
RETURNING "product_id", "product_name", "description", "unit_price", "supplier_id"
`

type CreateProductParams struct {
	ProductName string
	Description sql.NullString
	UnitPrice   float64
	SupplierID  int64
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) ([]Products, error) {
	rows, err := q.db.QueryContext(ctx, createProduct,
		arg.ProductName,
		arg.Description,
		arg.UnitPrice,
		arg.SupplierID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Products
	for rows.Next() {
		var i Products
		if err := rows.Scan(
			&i.ProductID,
			&i.ProductName,
			&i.Description,
			&i.UnitPrice,
			&i.SupplierID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProdcutById = `-- name: GetProdcutById :one
SELECT "product_id", "product_name", "description", "unit_price", "supplier_id" FROM "products"
WHERE "product_id" = 3
`

func (q *Queries) GetProdcutById(ctx context.Context) (Products, error) {
	row := q.db.QueryRowContext(ctx, getProdcutById)
	var i Products
	err := row.Scan(
		&i.ProductID,
		&i.ProductName,
		&i.Description,
		&i.UnitPrice,
		&i.SupplierID,
	)
	return i, err
}

const getProducts = `-- name: GetProducts :many
SELECT s."product_id", "location_id", "quantity", p."product_id", "product_name", "description", "unit_price", "supplier_id" FROM "stocks" AS s 
JOIN "products" p ON "p.product_id" = "s.product_id" 
WHERE ? = ? 
LIMIT ?
OFFSET ?
`

type GetProductsParams struct {
	Column1 interface{}
	Column2 interface{}
	Limit   int64
	Offset  int64
}

type GetProductsRow struct {
	ProductID   sql.NullInt64
	LocationID  sql.NullInt64
	Quantity    int64
	ProductID_2 int64
	ProductName string
	Description sql.NullString
	UnitPrice   float64
	SupplierID  int64
}

func (q *Queries) GetProducts(ctx context.Context, arg GetProductsParams) ([]GetProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, getProducts,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsRow
	for rows.Next() {
		var i GetProductsRow
		if err := rows.Scan(
			&i.ProductID,
			&i.LocationID,
			&i.Quantity,
			&i.ProductID_2,
			&i.ProductName,
			&i.Description,
			&i.UnitPrice,
			&i.SupplierID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE "products"
SET "unit_price" = ?, "description" = ?, "supplier_id" = ?
WHERE "product_id" = ?
RETURNING "product_id", "product_name", "description", "unit_price", "supplier_id"
`

type UpdateProductParams struct {
	UnitPrice   float64
	Description sql.NullString
	SupplierID  int64
	ProductID   int64
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Products, error) {
	row := q.db.QueryRowContext(ctx, updateProduct,
		arg.UnitPrice,
		arg.Description,
		arg.SupplierID,
		arg.ProductID,
	)
	var i Products
	err := row.Scan(
		&i.ProductID,
		&i.ProductName,
		&i.Description,
		&i.UnitPrice,
		&i.SupplierID,
	)
	return i, err
}
